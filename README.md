# fastify-zod

## Why?

`fastify` is awesome and arguably the best Node http server around.

`zod` is awesome and arguably the best TypeScript modeling / validation library around.

Unfortunately, `fastify` and `zod` don't work together very well. [`fastify` suggests using `@sinclair/typebox`](https://www.fastify.io/docs/latest/TypeScript/#typebox), which is nice but is nowhere close to `zod`. This library allows you to use `zod` as your primary source of truth for models with nice integration with `fastify`, `fastify-swagger` and OpenAPI `typescript-fetch` generator.

## Goals

- Use `zod` to validate input and output with type-safety in `fastify`
- Generate OpenAPI spec with `fastify-swagger` out of the box
- Generate OpenAPI client with `typescript-fetch` generator with human-friendly model names based on generated spec

## Examples

See the [fastify-zod-example](./fastify-zod-example) package for a full example, including generating an OpenAPI spec document and an OpenAPI client.

## Installation

You will need of course `fastify` and `zod`, but also `zod-to-json-schema` and `fastify-swagger`:

```
$ npm install --save fastify zod zod-to-json-schema fastify-swagger fastify-zod
```

## Usage

Define your models using `zod` as usual:

```ts
const TodoItemId = z.object({
  id: z.string().uuid(),
});
type TodoItemId = z.infer<typeof TodoItemId>;

const TodoItem = TodoItemId.extend({
  label: z.string(),
  dueDate: z.date().optional(),
  state: z.union([
    z.literal(`todo`),
    z.literal(`in progress`),
    z.literal(`done`),
  ]),
});

type TodoItem = z.infer<typeof TodoItem>;

const TodoItems = z.array(TodoItem);
type TodoItems = z.infer<typeof TodoItems>;
```

Then generate and register the schemas generated by this library:

```ts
import swagger from "fastify-swagger";
import { buildJsonSchemas, withRefResolver } from "..";

const { schemas, $ref } = buildJsonSchemas({
  TodoItemId,
  TodoItem,
  TodoItems,
});

for (const schema of schemas) {
  app.addSchema(schema);
}

app.register(
  swagger,
  withRefResolver({
    routePrefix: `/openapi`,
    exposeRoute: true,
    staticCSP: true,
    openapi: {
      info: {
        title: `Zod Fastify Test Server`,
        description: `API for Zod Fastify Test Server`,
        version: `0.0.0`,
      },
    },
  })
);
```

You can now define routes that will work nicely with `zod` for validation:

```ts
app.get<{
  Reply: TodoItems;
}>(
  `/item`,
  {
    schema: {
      operationId: `getTodoItems`,
      response: {
        200: $ref(`TodoItems`),
      },
    },
  },
  async () => /* ... */,
);

app.post<{
  Body: TodoItem;
  Reply: TodoItems;
}>(
  `/item`,
  {
    schema: {
      operationId: `postTodoItem`,
      body: $ref(`TodoItem`),
      response: {
        200: $ref(`TodoItems`),
      },
    },
  },
  async ({ body: nextItem }) => /* ... */,
);
```

You can also generate an OpenAPI spec document:

```ts
import { writeFile } from "fs/promises";
app
  .inject({
    method: "get",
    url: "/openapi/yaml",
  })
  .then((res) => writeFile("spec.yml", res.body));
```

And generate the corresponding client:

```
$ openapi-generator-cli generate
```

## Options

### buildJsonSchema options object

#### **target**?: `openApi3` | `jsonSchema7` defaults to (jsonSchema7)

Generates either `jsonSchema7` or `openApi3` schema. See [`zod-to-json-schema`](https://github.com/StefanTerdell/zod-to-json-schema#options-object).

### buildJsonSchemas options object

#### **target**?: `openApi3` | `jsonSchema7` defaults to (jsonSchema7)

Generates either `jsonSchema7` or `openApi3` schema. See [`zod-to-json-schema`](https://github.com/StefanTerdell/zod-to-json-schema#options-object).

#### mergeRefs?: boolean defaults to `false`

Recursively merge structurally-equivalent schemas as `$ref`s.

This is especially useful for enums, as equivalent enums will typically be generated as different `enum`s by downstream generators, and therefore will be treated as inequal by TypeScript.

For example:

```ts
enum FooFizzEnum {
  Foo = `Bar`,
  Fizz = `Buzz`,
}

const FooFizz = z.nativeEnum(FooFizzEnum);

const FooFizzItem = z.object({
  value: FooFizz,
});
```

Without `mergeRefs`, this yields:

```ts
equals(buildJsonSchemas({ FooFizz, FooFizzItem }).schemas, [
  {
    $id: `FooFizzItem`,
    $schema: `http://json-schema.org/draft-07/schema#`,
    type: `object`,
    properties: { value: { type: `string`, enum: [`Bar`, `Buzz`] } },
    required: [`value`],
    additionalProperties: false,
  },
  {
    $id: `FooFizz`,
    $schema: `http://json-schema.org/draft-07/schema#`,
    type: `string`,
    enum: [`Bar`, `Buzz`],
  },
]);
```

With `mergeRefs`, this yield:

```ts
equals(
  buildJsonSchemas({ FooFizz, FooFizzItem }, { mergeRefs: true }).schemas,
  [
    {
      $id: `FooFizzItem`,
      $schema: `http://json-schema.org/draft-07/schema#`,
      type: `object`,
      properties: { value: { $ref: `FooFizz#` } },
      required: [`value`],
      additionalProperties: false,
    },
    {
      $id: `FooFizz`,
      $schema: `http://json-schema.org/draft-07/schema#`,
      type: `string`,
      enum: [`Bar`, `Buzz`],
    },
  ]
);
```
